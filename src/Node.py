import networkx as nx 
import matplotlib.pyplot as plt
import random
import heapq
import datetime 

from Block import *
from networkx.drawing.nx_agraph import graphviz_layout
from Network import *
from Event import *

class Node: 

  def __init__(self, identifier, time, hash_power, master = None, upload_bandwidth=5):
    """
    Node class represent the mining nodes.

    Parameters
    ----------
    identifier : str
        ID of this node.
    time : timestamp
        Timestamp generated by the time module.
    hash_power : float
        Decimal repsent portion of hash power.
    upload_bandwidth : int
        Network b/w for uploading blocks.
    """
    self.id = identifier
    self.best_block = "genesis"
    self.block_dag = nx.DiGraph()
    self.block_dag.add_node("genesis", depth=1, prev = 'lol')
    self.created_blocks = []
    self.new_block = None

    # list of blocks seen by this node
    self.known_blocks = []
    
    # heap of tuples of the form (timestamp, event)
    self.event_buffer = []

    # list of blocks to buffer
    self.gossip_buffer = []

    # MB/s upload speed
    # assuming each block is 1 MB, this is the number of blocks that can be gossiped per second
    self.upload_bandwidth = upload_bandwidth

    self.time = time

    self.neighbours = None

    self.hash_power = hash_power

    block_time = 1 / hash_power * Block.AVG_GEN_TIME

    self.block_rate = 1 / block_time

    self.master = master


  def append_block(self, block):
    """
    Append a block to the local DAG:
      - append to DAG if the prev hash has seen
      - create new fork if not

    Parameters
    ----------
    block : Block
        A new block to append.
    """
    # skip if block is already s een
    if block.block_hash in self.block_dag.nodes:
      return

    prev_block = block.prev_hash
    self.latest_block = block

    # if parent block has been seen
    if prev_block in self.block_dag.nodes:
      prev_depth = self.block_dag.nodes[prev_block]['depth']
      self.block_dag.add_node(block.block_hash, depth = prev_depth + 1, block = block, prev = prev_block)
      self.block_dag.add_edge(prev_block, block.block_hash) 
    
    # if parent block have not yet been seen
    else:
      self.block_dag.add_node(block.block_hash, prev = block.prev_hash, depth=1, block = block)
    
    # if we are connecting a disjoint graph with the main graph
    depth = self.block_dag.nodes[block.block_hash]['depth']
    children = [b for b,d in self.block_dag.nodes(data=True) if d['prev'] == block.block_hash]
    if children != []:
      for c in children:
        self.block_dag.add_edge(block.block_hash, c)
        tree = nx.bfs_tree(self.block_dag, c)
        for node in tree.nodes:
          self.block_dag.nodes[node]['depth'] += depth


  def create_block(self, block):
    """
    The simulator notifies this node to
    create a new block. This node will:
      1. append to local DAG
      2. cache this block locally
      3. gossip to neighbours

    Parameters
    ----------
    block : Block
        The newly created block instance.
    """
    candidates = []

    candidates = self.get_candidates()
    #print("Candidates are {}".format(candidates))
    #print("Previous hash is {}".format(block.prev_hash))

    if block.prev_hash in candidates:
        print("Node {} generated block {} at time {}".format(self.id, block.block_hash, self.time))
        self.append_block(block)
        self.master.append_block(block)

        self.created_blocks.append(block.block_hash)
        self.create_block_event()

        self.gossip_buffer.append(block)
    self.master.draw_dag

  def gossip_block(self):
    """
    Gossip whatever there is in the `gossip_buffer` to neighbours.
    This process involves:
      1. package the blocks in `gossip_buffer` into events with proper timestamp
      2. push the events into event queue. (event queue will be sorted by timestamp latency)

    Events in the event queue will be processed asyncly.
    """
    # self.create_block("longest_chain")
    # gossip all blocks in buffer
    # can be tweaked to only gossip blocks not yet gossipped 
    counter = 0
    #print("Node {} has {} items to gossip".format(self.id, len(self.gossip_buffer)))
    while self.gossip_buffer:
      block = self.gossip_buffer.pop()

      #print("Neighbours: {}".format([n.id for n in self.neighbours]))
      for node in self.neighbours:
        #print(node.id)
        node_time = node.time
        # dont gossip to nodes that have already seen this node
        if block in node.known_blocks:
          continue
        
        # generate receive timestamp 
        delay = datetime.timedelta(seconds=(counter // self.upload_bandwidth))
        # delay = datetime.timedelta(0)

        timestamp = node_time + delay + Network.AVERAGE_NETWORK_DELAY
        event = Event(EventType.RECEIVE_BLOCK, block, timestamp)

        # if block.block_hash in node.gossip_hash:
          #if timestamp < node.gossip_hash[block.block_hash]:
        heapq.heappush(node.event_buffer, event)
        #print("Node {} gossips block {} to Node {}".format(self.id, block.block_hash, node.id))

        counter += 1

  def process_event(self):
    """
    Process events in the local event queue. This will check if we are "able" to process the
    nearest future events (i.e. if local time has passed the event time)
    """
    # update current timestamp
    self.time = self.event_buffer[0].timestamp
    
    # if not self.event_buffer:
    #     return
    
    # check if any events should be processed
    #print("Node {} has {} items to process".format(self.id, len(self.event_buffer)))
    while self.event_buffer[0].timestamp <= self.time:
      #print("processing event queue of {}".format(self.id))
      #print(len(self.event_buffer))
      event = heapq.heappop(self.event_buffer)

      if event.event_type == EventType.CREATE_BLOCK:
        self.create_block(event.block)
        #print("Node {} processing create block".format(self.id))
      else:
        self.append_block(event.block)
        if event.block not in self.known_blocks:
          self.gossip_buffer.append(event.block)
        #print("Node {} processing block {}".format(self.id, event.block.block_hash))
      
        candidates = self.get_candidates()
        
        if self.best_block not in candidates:
          self.create_block_event()

      self.clean_event_buffer(event.block)
      self.known_blocks.append(event.block)
    
    self.gossip_block()

  def clean_event_buffer(self, block):
    """
    Cleans the event buffer of duplicate receieve events of the same block.

    Parameters
    ----------
    block : Block
        The block to be sanitized.
    """
    new_buffer = []
    for event in self.event_buffer:
      if event.block != block:
        new_buffer.append(event)
    heapq.heapify(new_buffer)
    self.event_buffer = new_buffer

  def create_block_event(self):
    # figure out when to generate the next block
    #print(self.block_time)
    time_to_generate = random.expovariate(self.block_rate)
    timestamp = self.time + datetime.timedelta(minutes=(time_to_generate))

    candidates = []
    # figure out where to append this block
    candidates = self.get_candidates()

    # tie breaker
    parent = random.choice(candidates)
    self.best_block = parent
    block = Block(parent, self.id)
    #print("Node {} will generate block {} in {}".format(self.id, block.block_hash, time_to_generate))
    event = Event(EventType.CREATE_BLOCK, block, timestamp)

    heapq.heappush(self.event_buffer, event)
  
  def get_longest_chain_blocks(self):
    # for b, d in self.block_dag.nodes(data=True):
    #   print(d)
    tree = nx.bfs_tree(self.block_dag, "genesis")
    nodes = tree.nodes
    max_len = len(nx.dag_longest_path(tree))
    return [b for b,d in self.block_dag.nodes(data=True) if (d['depth'] == max_len) and (b in nodes)]

  def get_ghost_blocks(self):
    node = "genesis"

    while len(self.block_dag[node]) > 0:
      children = list(self.block_dag[node])
      sizes = [len(nx.bfs_tree(self.block_dag, c).nodes) for c in children]
      largest_index = sizes.index(max(sizes))
      node = children[largest_index]
    
    return [node]
  
  def draw_dag(self):
    position = graphviz_layout(self.block_dag, prog='dot', args='-Gnodesep=5 -Granksep=5 -Gpad=1')
    colours = []
    for n, data in self.block_dag.nodes(data=True):
      if n == "genesis":
        colours.append("#0050bc")
        continue 
      block = data['block']
      colours.append(block.colour)
    #print(colours)

    nx.draw(self.block_dag, position, with_labels=True, arrows=True, node_size=100, font_size=8, node_color=colours)
    if self.id == "master":
      plt.savefig("{}_block_dag.png".format(self.id))
    else:
      plt.savefig("../graphs/{}_block_dag.png".format(self.id), dpi=300)

    # clear the figure or else subsequent graphs will be combined for some reason
    plt.clf()

  # returns the time until the next event 
  def next_interval(self):
    timestamp = self.event_buffer[0].timestamp
    timedelta = timestamp - self.time 
    return timedelta

  def update_neighbours(self, nodes):
    random.shuffle(nodes)
    self.neighbours = nodes

  def get_candidates(self):
    if Block.METHOD == "longest_chain":
      return self.get_longest_chain_blocks()
    elif Block.METHOD == "ghost":
      return self.get_ghost_blocks()


  def print_stats(self):
    print("Node {} stats: ".format(self.id))
    print(" hash power: {}".format(self.hash_power))
    print(" blocks generated: {}".format(len(self.created_blocks)))

  def observe_create_events(self):
    for i in self.event_buffer:
        if i.event_type == EventType.CREATE_BLOCK:
          print("Next creation event for Node {} is {}".format(self.id, i.timestamp))


  def update_master(self, master, block):
    master.append_block(block)

  def pass_time(self, time):
    self.time += time

  def abandoned_blocks(self):
    total_len = len(self.block_dag.nodes)
    if Block.METHOD == "longest_chain":
      tree = nx.bfs_tree(self.block_dag, "genesis")
      max_len = len(nx.dag_longest_path(tree))

      return total_len - max_len
    elif Block.METHOD == "ghost":
      count = 0
      node = "genesis"

      while len(self.block_dag[node]) > 0:
        children = list(self.block_dag[node])
        sizes = [len(nx.bfs_tree(self.block_dag, c).nodes) for c in children]
        largest_index = sizes.index(max(sizes))
        count += max(sizes)
        node = children[largest_index]
      
      return total_len - count




if __name__ == "__main__":
  n = Node("test")
  n.create_block("longest_chain")
  n.create_block("longest_chain")
  n.draw_dag()
